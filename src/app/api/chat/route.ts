/* eslint-disable @typescript-eslint/restrict-template-expressions */
/* eslint-disable @typescript-eslint/no-explicit-any */
/* eslint-disable @typescript-eslint/ban-ts-comment */
import {
  streamText,
  type CoreMessage,
  tool as aiTool,
  type CoreSystemMessage,
} from "ai";
import { createGoogleGenerativeAI } from "@ai-sdk/google";
import { createOpenAI } from "@ai-sdk/openai";
import { createAnthropic } from "@ai-sdk/anthropic";
import { createDeepSeek } from "@ai-sdk/deepseek"; // Import DeepSeek
import { type Tool } from "@/types/tool";
import * as z from "zod";

// Allow streaming responses up to 30 seconds
export const maxDuration = 30;

export async function POST(req: Request) {
  const { messages, apiKeys, model, tools } = (await req.json()) as {
    messages: CoreMessage[];
    apiKeys: Record<string, string>;
    model: string;
    tools: Tool[];
  };

  const aiTools = tools.reduce(
    (acc, tool) => {
      // @ts-ignore
      acc[tool.name] = aiTool({
        description: tool.description ?? "",
        execute: async (args: Record<string, any>): Promise<string> => {
          const resultString = tool.prompt.replace(/{(\w+)}/g, (_, key) => {
            if (key in args) {
              if (Array.isArray(args[key])) {
                return args[key].map((item: string) => `"${item}"`).join(", ");
              }
              return args[key];
            }
            return `{${key}}`;
          });
          return resultString;
        },
        parameters: z.object(
          (tool.args || []).reduce(
            (acc, arg) => {
              let argType: z.ZodTypeAny;

              if (arg.type === "array") {
                argType = z.array(z.string()).describe(arg.description);
              } else if (arg.type === "number") {
                argType = z.number().describe(arg.description);
              } else if (arg.type === "string") {
                argType = z.string().describe(arg.description);
              } else {
                throw new Error(`Unsupported argument type: ${arg.type}`);
              }

              acc[arg.name] = argType;
              return acc;
            },
            {} as Record<string, z.ZodTypeAny>,
          ),
        ),
      });
      return acc;
    },
    {} as Record<string, ReturnType<typeof aiTool>>,
  );

  if (!model) {
    return new Response("Model is missing.", { status: 400 });
  }

  const [provider, modelCode] = model.split("/");

  let selectedModel;
  let selectedApiKey;

  switch (provider) {
    case "google":
      selectedApiKey = apiKeys.google;
      if (!selectedApiKey) {
        return new Response("Google AI API Key is missing.", { status: 400 });
      }
      selectedModel = createGoogleGenerativeAI({ apiKey: selectedApiKey })(
        `models/${modelCode}`, // Prepend 'models/' for Google
      );
      break;
    case "deepseek":
      selectedApiKey = apiKeys.deepseek;
      if (!selectedApiKey) {
        return new Response("DeepSeek AI API Key is missing.", { status: 400 });
      }
      selectedModel = createDeepSeek({ apiKey: selectedApiKey })(
        modelCode as "deepseek-chat",
      );
      break;
    case "openai":
      selectedApiKey = apiKeys.openai;
      if (!selectedApiKey) {
        return new Response("OpenAI API Key is missing.", { status: 400 });
      }
      selectedModel = createOpenAI({ apiKey: selectedApiKey })(
        modelCode as "gpt-4.1-mini",
      );
      break;
    case "anthropic":
      selectedApiKey = apiKeys.anthropic;
      if (!selectedApiKey) {
        return new Response("Anthropic API Key is missing.", { status: 400 });
      }
      selectedModel = createAnthropic({ apiKey: selectedApiKey })(
        modelCode as "claude-4-sonnet",
      );
      break;
    default:
      return new Response(`Unsupported AI provider: ${provider}`, {
        status: 400,
      });
  }

  const result = streamText({
    model: selectedModel,
    messages: messages.map(
      (message: CoreMessage & { annotations?: { toolName?: string } }) => {
        if (message.annotations?.toolName) {
          return {
            ...message,
            content: `${message?.content as string}\n\n**IMPORTANT**: This message is generated by the tool **${message.annotations?.toolName}** so please DO NOT invoke it right after the message to avoid a loop.`,
          } as CoreSystemMessage;
        }
        return message;
      },
    ),
    tools: aiTools,
  });

  return result.toDataStreamResponse();
}
